"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+ciphers@2.0.1";
exports.ids = ["vendor-chunks/@noble+ciphers@2.0.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_arx.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_arx.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _XorStreamPRG: () => (/* binding */ _XorStreamPRG),\n/* harmony export */   createCipher: () => (/* binding */ createCipher),\n/* harmony export */   createPRG: () => (/* binding */ createPRG),\n/* harmony export */   rotl: () => (/* binding */ rotl)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js\");\n/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | cnt(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\n\n// Replaces `TextEncoder`, which is not available in all environments\nconst encodeStr = (str) => Uint8Array.from(str.split(''), (c) => c.charCodeAt(0));\nconst sigma16 = encodeStr('expand 16-byte k');\nconst sigma32 = encodeStr('expand 32-byte k');\nconst sigma16_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma16);\nconst sigma32_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma32);\n/** Rotate left. */\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = Uint32Array.of();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(counterLength);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(rounds);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(counterRight);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, undefined, 'key');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(nonce, undefined, 'nonce');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data, undefined, 'data');\n        const len = data.length;\n        if (output === undefined)\n            output = new Uint8Array(len);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(output, undefined, 'output');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length;\n        let k;\n        let sigma;\n        if (l === 32) {\n            toClean.push((k = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(key)));\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'arx key');\n            throw new Error('invalid key size');\n            // throw new Error(`\"arx key\" expected Uint8Array of length 32, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce))\n            toClean.push((nonce = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(nonce)));\n        const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(...toClean);\n        return output;\n    };\n}\n/** Internal class which wraps chacha20 or chacha8 to create CSPRNG. */\nclass _XorStreamPRG {\n    blockLen;\n    keyLen;\n    nonceLen;\n    state;\n    buf;\n    key;\n    nonce;\n    pos;\n    ctr;\n    cipher;\n    constructor(cipher, blockLen, keyLen, nonceLen, seed) {\n        this.cipher = cipher;\n        this.blockLen = blockLen;\n        this.keyLen = keyLen;\n        this.nonceLen = nonceLen;\n        this.state = new Uint8Array(this.keyLen + this.nonceLen);\n        this.reseed(seed);\n        this.ctr = 0;\n        this.pos = this.blockLen;\n        this.buf = new Uint8Array(this.blockLen);\n        this.key = this.state.subarray(0, this.keyLen);\n        this.nonce = this.state.subarray(this.keyLen);\n    }\n    reseed(seed) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(seed);\n        if (!seed || seed.length === 0)\n            throw new Error('entropy required');\n        for (let i = 0; i < seed.length; i++)\n            this.state[i % this.state.length] ^= seed[i];\n        this.ctr = 0;\n        this.pos = this.blockLen;\n    }\n    addEntropy(seed) {\n        this.state.set(this.randomBytes(this.state.length));\n        this.reseed(seed);\n    }\n    randomBytes(len) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(len);\n        if (len === 0)\n            return new Uint8Array(0);\n        const out = new Uint8Array(len);\n        let outPos = 0;\n        // Leftovers\n        if (this.pos < this.blockLen) {\n            const take = Math.min(len, this.blockLen - this.pos);\n            out.set(this.buf.subarray(this.pos, this.pos + take), 0);\n            this.pos += take;\n            outPos += take;\n            if (outPos === len)\n                return out; // fast path\n        }\n        // Full blocks directly to out\n        const blocks = Math.floor((len - outPos) / this.blockLen);\n        if (blocks > 0) {\n            const blockBytes = blocks * this.blockLen;\n            const b = out.subarray(outPos, outPos + blockBytes);\n            this.cipher(this.key, this.nonce, b, b, this.ctr);\n            this.ctr += blocks;\n            outPos += blockBytes;\n        }\n        // Save leftovers\n        const left = len - outPos;\n        if (left > 0) {\n            this.buf.fill(0);\n            // NOTE: cipher will handle overflow\n            this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);\n            out.set(this.buf.subarray(0, left), outPos);\n            this.pos = left;\n        }\n        return out;\n    }\n    clone() {\n        return new _XorStreamPRG(this.cipher, this.blockLen, this.keyLen, this.nonceLen, this.randomBytes(this.state.length));\n    }\n    clean() {\n        this.pos = 0;\n        this.ctr = 0;\n        this.buf.fill(0);\n        this.state.fill(0);\n    }\n}\nconst createPRG = (cipher, blockLen, keyLen, nonceLen) => {\n    return (seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) => new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);\n};\n//# sourceMappingURL=_arx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2NpcGhlcnNAMi4wLjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19hcnguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQUc7QUFDdEIsbUJBQW1CLDhDQUFHO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBRztBQUNuQjtBQUNBO0FBQ0EsNEJBQTRCLDhDQUFHO0FBQy9CLDRCQUE0Qiw4Q0FBRztBQUMvQixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFFQUFxRSxFQUFFLG9EQUFTLEdBQUcsMEVBQTBFO0FBQ3pLO0FBQ0E7QUFDQSxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxrREFBTztBQUNYLElBQUksZ0RBQUs7QUFDVCxJQUFJLGdEQUFLO0FBQ1Q7QUFDQSxRQUFRLGlEQUFNO0FBQ2QsUUFBUSxpREFBTTtBQUNkLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFNO0FBQ2QsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjLDBCQUEwQixJQUFJO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFNO0FBQ2xCO0FBQ0EseUZBQXlGLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFTO0FBQzNDLG9CQUFvQiw4Q0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4Q0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQUc7QUFDdkI7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLHNEQUFXO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXdzLWh1Yi8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY2lwaGVyc0AyLjAuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvX2FyeC5qcz9jZmY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFzaWMgdXRpbHMgZm9yIEFSWCAoYWRkLXJvdGF0ZS14b3IpIHNhbHNhIGFuZCBjaGFjaGEgY2lwaGVycy5cblxuUkZDODQzOSByZXF1aXJlcyBtdWx0aS1zdGVwIGNpcGhlciBzdHJlYW0sIHdoZXJlXG5hdXRoS2V5IHN0YXJ0cyB3aXRoIGNvdW50ZXI6IDAsIGFjdHVhbCBtc2cgd2l0aCBjb3VudGVyOiAxLlxuXG5Gb3IgdGhpcywgd2UgbmVlZCBhIHdheSB0byByZS11c2Ugbm9uY2UgLyBjb3VudGVyOlxuXG4gICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDFcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAyXG5cblRoaXMgaXMgY29tcGxpY2F0ZWQ6XG5cbi0gMzItYml0IGNvdW50ZXJzIGFyZSBlbm91Z2gsIG5vIG5lZWQgZm9yIDY0LWJpdDogbWF4IEFycmF5QnVmZmVyIHNpemUgaW4gSlMgaXMgNEdCXG4tIE9yaWdpbmFsIHBhcGVycyBkb24ndCBhbGxvdyBtdXRhdGluZyBjb3VudGVyc1xuLSBDb3VudGVyIG92ZXJmbG93IGlzIHVuZGVmaW5lZCBbXjFdXG4tIElkZWEgQTogYWxsb3cgcHJvdmlkaW5nIChub25jZSB8IGNvdW50ZXIpIGluc3RlYWQgb2YganVzdCBub25jZSwgcmUtdXNlIGl0XG4tIENhdmVhdDogQ2Fubm90IGJlIHJlLXVzZWQgdGhyb3VnaCBhbGwgY2FzZXM6XG4tICogY2hhY2hhIGhhcyAoY291bnRlciB8IG5vbmNlKVxuLSAqIHhjaGFjaGEgaGFzIChub25jZTE2IHwgY291bnRlciB8IG5vbmNlMTYpXG4tIElkZWEgQjogc2VwYXJhdGUgbm9uY2UgLyBjb3VudGVyIGFuZCBwcm92aWRlIHNlcGFyYXRlIEFQSSBmb3IgY291bnRlciByZS11c2Vcbi0gQ2F2ZWF0OiB0aGVyZSBhcmUgZGlmZmVyZW50IGNvdW50ZXIgc2l6ZXMgZGVwZW5kaW5nIG9uIGFuIGFsZ29yaXRobS5cbi0gc2Fsc2EgJiBjaGFjaGEgYWxzbyBkaWZmZXIgaW4gc3RydWN0dXJlcyBvZiBrZXkgJiBzaWdtYTpcbiAgc2Fsc2EyMDogICAgICBzWzBdIHwgayg0KSB8IHNbMV0gfCBub25jZSgyKSB8IGNudCgyKSB8IHNbMl0gfCBrKDQpIHwgc1szXVxuICBjaGFjaGE6ICAgICAgIHMoNCkgfCBrKDgpIHwgY250KDEpIHwgbm9uY2UoMylcbiAgY2hhY2hhMjBvcmlnOiBzKDQpIHwgayg4KSB8IGNudCgyKSB8IG5vbmNlKDIpXG4tIElkZWEgQzogaGVscGVyIG1ldGhvZCBzdWNoIGFzIGBzZXRTYWxzYVN0YXRlKGtleSwgbm9uY2UsIHNpZ21hLCBkYXRhKWBcbi0gQ2F2ZWF0OiB3ZSBjYW4ndCByZS11c2UgY291bnRlciBhcnJheVxuXG54Y2hhY2hhIFteMl0gdXNlcyB0aGUgc3Via2V5IGFuZCByZW1haW5pbmcgOCBieXRlIG5vbmNlIHdpdGggQ2hhQ2hhMjAgYXMgbm9ybWFsXG4ocHJlZml4ZWQgYnkgNCBOVUwgYnl0ZXMsIHNpbmNlIFtSRkM4NDM5XSBzcGVjaWZpZXMgYSAxMi1ieXRlIG5vbmNlKS5cblxuW14xXTogaHR0cHM6Ly9tYWlsYXJjaGl2ZS5pZXRmLm9yZy9hcmNoL21zZy9jZnJnL2dzT25USnpjYmdHNk9xRDhTYzBHTzVhUl90VS9cblteMl06IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEjYXBwZW5kaXgtQS4yXG5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJvb2wsIGFieXRlcywgYW51bWJlciwgY2hlY2tPcHRzLCBjbGVhbiwgY29weUJ5dGVzLCByYW5kb21CeXRlcywgdTMyLCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBSZXBsYWNlcyBgVGV4dEVuY29kZXJgLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHNcbmNvbnN0IGVuY29kZVN0ciA9IChzdHIpID0+IFVpbnQ4QXJyYXkuZnJvbShzdHIuc3BsaXQoJycpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcbmNvbnN0IHNpZ21hMTYgPSBlbmNvZGVTdHIoJ2V4cGFuZCAxNi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMzIgPSBlbmNvZGVTdHIoJ2V4cGFuZCAzMi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMTZfMzIgPSB1MzIoc2lnbWExNik7XG5jb25zdCBzaWdtYTMyXzMyID0gdTMyKHNpZ21hMzIpO1xuLyoqIFJvdGF0ZSBsZWZ0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwoYSwgYikge1xuICAgIHJldHVybiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG59XG4vLyBJcyBieXRlIGFycmF5IGFsaWduZWQgdG8gNCBieXRlIG9mZnNldCAodTMyKT9cbmZ1bmN0aW9uIGlzQWxpZ25lZDMyKGIpIHtcbiAgICByZXR1cm4gYi5ieXRlT2Zmc2V0ICUgNCA9PT0gMDtcbn1cbi8vIFNhbHNhIGFuZCBDaGFjaGEgYmxvY2sgbGVuZ3RoIGlzIGFsd2F5cyA1MTItYml0XG5jb25zdCBCTE9DS19MRU4gPSA2NDtcbmNvbnN0IEJMT0NLX0xFTjMyID0gMTY7XG4vLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyXSkgICAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDAgXVxuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMi0xXSkgLy8gPT4gVWludDMyQXJyYXkoMSkgWyA0Mjk0OTY3Mjk1IF1cbmNvbnN0IE1BWF9DT1VOVEVSID0gMiAqKiAzMiAtIDE7XG5jb25zdCBVMzJfRU1QVFkgPSBVaW50MzJBcnJheS5vZigpO1xuZnVuY3Rpb24gcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIsIHJvdW5kcykge1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGJsb2NrID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfTEVOKTtcbiAgICBjb25zdCBiMzIgPSB1MzIoYmxvY2spO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJ1ZmZlcnMgYWxpZ25lZCB0byA0IGJ5dGVzXG4gICAgY29uc3QgaXNBbGlnbmVkID0gaXNBbGlnbmVkMzIoZGF0YSkgJiYgaXNBbGlnbmVkMzIob3V0cHV0KTtcbiAgICBjb25zdCBkMzIgPSBpc0FsaWduZWQgPyB1MzIoZGF0YSkgOiBVMzJfRU1QVFk7XG4gICAgY29uc3QgbzMyID0gaXNBbGlnbmVkID8gdTMyKG91dHB1dCkgOiBVMzJfRU1QVFk7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyBjb3VudGVyKyspIHtcbiAgICAgICAgY29yZShzaWdtYSwga2V5LCBub25jZSwgYjMyLCBjb3VudGVyLCByb3VuZHMpO1xuICAgICAgICBpZiAoY291bnRlciA+PSBNQVhfQ09VTlRFUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihCTE9DS19MRU4sIGxlbiAtIHBvcyk7XG4gICAgICAgIC8vIGFsaWduZWQgdG8gNCBieXRlc1xuICAgICAgICBpZiAoaXNBbGlnbmVkICYmIHRha2UgPT09IEJMT0NLX0xFTikge1xuICAgICAgICAgICAgY29uc3QgcG9zMzIgPSBwb3MgLyA0O1xuICAgICAgICAgICAgaWYgKHBvcyAlIDQgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGludmFsaWQgYmxvY2sgcG9zaXRpb24nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOyBqIDwgQkxPQ0tfTEVOMzI7IGorKykge1xuICAgICAgICAgICAgICAgIHBvc2ogPSBwb3MzMiArIGo7XG4gICAgICAgICAgICAgICAgbzMyW3Bvc2pdID0gZDMyW3Bvc2pdIF4gYjMyW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IEJMT0NLX0xFTjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOyBqIDwgdGFrZTsgaisrKSB7XG4gICAgICAgICAgICBwb3NqID0gcG9zICsgajtcbiAgICAgICAgICAgIG91dHB1dFtwb3NqXSA9IGRhdGFbcG9zal0gXiBibG9ja1tqXTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBBUlgtbGlrZSAoQ2hhQ2hhLCBTYWxzYSkgY2lwaGVyIHN0cmVhbSBmcm9tIGNvcmUgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2lwaGVyKGNvcmUsIG9wdHMpIHtcbiAgICBjb25zdCB7IGFsbG93U2hvcnRLZXlzLCBleHRlbmROb25jZUZuLCBjb3VudGVyTGVuZ3RoLCBjb3VudGVyUmlnaHQsIHJvdW5kcyB9ID0gY2hlY2tPcHRzKHsgYWxsb3dTaG9ydEtleXM6IGZhbHNlLCBjb3VudGVyTGVuZ3RoOiA4LCBjb3VudGVyUmlnaHQ6IGZhbHNlLCByb3VuZHM6IDIwIH0sIG9wdHMpO1xuICAgIGlmICh0eXBlb2YgY29yZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIGFudW1iZXIoY291bnRlckxlbmd0aCk7XG4gICAgYW51bWJlcihyb3VuZHMpO1xuICAgIGFib29sKGNvdW50ZXJSaWdodCk7XG4gICAgYWJvb2woYWxsb3dTaG9ydEtleXMpO1xuICAgIHJldHVybiAoa2V5LCBub25jZSwgZGF0YSwgb3V0cHV0LCBjb3VudGVyID0gMCkgPT4ge1xuICAgICAgICBhYnl0ZXMoa2V5LCB1bmRlZmluZWQsICdrZXknKTtcbiAgICAgICAgYWJ5dGVzKG5vbmNlLCB1bmRlZmluZWQsICdub25jZScpO1xuICAgICAgICBhYnl0ZXMoZGF0YSwgdW5kZWZpbmVkLCAnZGF0YScpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgYWJ5dGVzKG91dHB1dCwgdW5kZWZpbmVkLCAnb3V0cHV0Jyk7XG4gICAgICAgIGFudW1iZXIoY291bnRlcik7XG4gICAgICAgIGlmIChjb3VudGVyIDwgMCB8fCBjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPCBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogb3V0cHV0ICgke291dHB1dC5sZW5ndGh9KSBpcyBzaG9ydGVyIHRoYW4gZGF0YSAoJHtsZW59KWApO1xuICAgICAgICBjb25zdCB0b0NsZWFuID0gW107XG4gICAgICAgIC8vIEtleSAmIHNpZ21hXG4gICAgICAgIC8vIGtleT0xNiAtPiBzaWdtYTE2LCBrPWtleXxrZXlcbiAgICAgICAgLy8ga2V5PTMyIC0+IHNpZ21hMzIsIGs9a2V5XG4gICAgICAgIGxldCBsID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGxldCBzaWdtYTtcbiAgICAgICAgaWYgKGwgPT09IDMyKSB7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2goKGsgPSBjb3B5Qnl0ZXMoa2V5KSkpO1xuICAgICAgICAgICAgc2lnbWEgPSBzaWdtYTMyXzMyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDE2ICYmIGFsbG93U2hvcnRLZXlzKSB7XG4gICAgICAgICAgICBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICAgICAgay5zZXQoa2V5KTtcbiAgICAgICAgICAgIGsuc2V0KGtleSwgMTYpO1xuICAgICAgICAgICAgc2lnbWEgPSBzaWdtYTE2XzMyO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJ5dGVzKGtleSwgMzIsICdhcngga2V5Jyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2V5IHNpemUnKTtcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgXCJhcngga2V5XCIgZXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggMzIsIGdvdCBsZW5ndGg9JHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbmNlXG4gICAgICAgIC8vIHNhbHNhMjA6ICAgICAgOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8gY2hhY2hhMjBvcmlnOiA4ICAgKDgtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyBjaGFjaGEyMDogICAgIDEyICAoNC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIHhzYWxzYTIwOiAgICAgMjQgICgxNiAtPiBoc2Fsc2EsICA4IC0+IG9sZCBub25jZSlcbiAgICAgICAgLy8geGNoYWNoYTIwOiAgICAyNCAgKDE2IC0+IGhjaGFjaGEsIDggLT4gb2xkIG5vbmNlKVxuICAgICAgICAvLyBBbGlnbiBub25jZSB0byA0IGJ5dGVzXG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIobm9uY2UpKVxuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChub25jZSA9IGNvcHlCeXRlcyhub25jZSkpKTtcbiAgICAgICAgY29uc3QgazMyID0gdTMyKGspO1xuICAgICAgICAvLyBoc2Fsc2EgJiBoY2hhY2hhOiBoYW5kbGUgZXh0ZW5kZWQgbm9uY2VcbiAgICAgICAgaWYgKGV4dGVuZE5vbmNlRm4pIHtcbiAgICAgICAgICAgIGlmIChub25jZS5sZW5ndGggIT09IDI0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBleHRlbmRlZCBub25jZSBtdXN0IGJlIDI0IGJ5dGVzYCk7XG4gICAgICAgICAgICBleHRlbmROb25jZUZuKHNpZ21hLCBrMzIsIHUzMihub25jZS5zdWJhcnJheSgwLCAxNikpLCBrMzIpO1xuICAgICAgICAgICAgbm9uY2UgPSBub25jZS5zdWJhcnJheSgxNik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG5vbmNlIGNvdW50ZXJcbiAgICAgICAgY29uc3Qgbm9uY2VOY0xlbiA9IDE2IC0gY291bnRlckxlbmd0aDtcbiAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IG5vbmNlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBub25jZSBtdXN0IGJlICR7bm9uY2VOY0xlbn0gb3IgMTYgYnl0ZXNgKTtcbiAgICAgICAgLy8gUGFkIGNvdW50ZXIgd2hlbiBub25jZSBpcyA2NCBiaXRcbiAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IDEyKSB7XG4gICAgICAgICAgICBjb25zdCBuYyA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICAgICAgICAgIG5jLnNldChub25jZSwgY291bnRlclJpZ2h0ID8gMCA6IDEyIC0gbm9uY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIG5vbmNlID0gbmM7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2gobm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4zMiA9IHUzMihub25jZSk7XG4gICAgICAgIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwgazMyLCBuMzIsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKTtcbiAgICAgICAgY2xlYW4oLi4udG9DbGVhbik7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbi8qKiBJbnRlcm5hbCBjbGFzcyB3aGljaCB3cmFwcyBjaGFjaGEyMCBvciBjaGFjaGE4IHRvIGNyZWF0ZSBDU1BSTkcuICovXG5leHBvcnQgY2xhc3MgX1hvclN0cmVhbVBSRyB7XG4gICAgYmxvY2tMZW47XG4gICAga2V5TGVuO1xuICAgIG5vbmNlTGVuO1xuICAgIHN0YXRlO1xuICAgIGJ1ZjtcbiAgICBrZXk7XG4gICAgbm9uY2U7XG4gICAgcG9zO1xuICAgIGN0cjtcbiAgICBjaXBoZXI7XG4gICAgY29uc3RydWN0b3IoY2lwaGVyLCBibG9ja0xlbiwga2V5TGVuLCBub25jZUxlbiwgc2VlZCkge1xuICAgICAgICB0aGlzLmNpcGhlciA9IGNpcGhlcjtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLmtleUxlbiA9IGtleUxlbjtcbiAgICAgICAgdGhpcy5ub25jZUxlbiA9IG5vbmNlTGVuO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5rZXlMZW4gKyB0aGlzLm5vbmNlTGVuKTtcbiAgICAgICAgdGhpcy5yZXNlZWQoc2VlZCk7XG4gICAgICAgIHRoaXMuY3RyID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLmJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLmtleSA9IHRoaXMuc3RhdGUuc3ViYXJyYXkoMCwgdGhpcy5rZXlMZW4pO1xuICAgICAgICB0aGlzLm5vbmNlID0gdGhpcy5zdGF0ZS5zdWJhcnJheSh0aGlzLmtleUxlbik7XG4gICAgfVxuICAgIHJlc2VlZChzZWVkKSB7XG4gICAgICAgIGFieXRlcyhzZWVkKTtcbiAgICAgICAgaWYgKCFzZWVkIHx8IHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyb3B5IHJlcXVpcmVkJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3RhdGVbaSAlIHRoaXMuc3RhdGUubGVuZ3RoXSBePSBzZWVkW2ldO1xuICAgICAgICB0aGlzLmN0ciA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5ibG9ja0xlbjtcbiAgICB9XG4gICAgYWRkRW50cm9weShzZWVkKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KHRoaXMucmFuZG9tQnl0ZXModGhpcy5zdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5yZXNlZWQoc2VlZCk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzKGxlbikge1xuICAgICAgICBhbnVtYmVyKGxlbik7XG4gICAgICAgIGlmIChsZW4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGxldCBvdXRQb3MgPSAwO1xuICAgICAgICAvLyBMZWZ0b3ZlcnNcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5ibG9ja0xlbikge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGxlbiwgdGhpcy5ibG9ja0xlbiAtIHRoaXMucG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQodGhpcy5idWYuc3ViYXJyYXkodGhpcy5wb3MsIHRoaXMucG9zICsgdGFrZSksIDApO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIG91dFBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKG91dFBvcyA9PT0gbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7IC8vIGZhc3QgcGF0aFxuICAgICAgICB9XG4gICAgICAgIC8vIEZ1bGwgYmxvY2tzIGRpcmVjdGx5IHRvIG91dFxuICAgICAgICBjb25zdCBibG9ja3MgPSBNYXRoLmZsb29yKChsZW4gLSBvdXRQb3MpIC8gdGhpcy5ibG9ja0xlbik7XG4gICAgICAgIGlmIChibG9ja3MgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja0J5dGVzID0gYmxvY2tzICogdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBvdXQuc3ViYXJyYXkob3V0UG9zLCBvdXRQb3MgKyBibG9ja0J5dGVzKTtcbiAgICAgICAgICAgIHRoaXMuY2lwaGVyKHRoaXMua2V5LCB0aGlzLm5vbmNlLCBiLCBiLCB0aGlzLmN0cik7XG4gICAgICAgICAgICB0aGlzLmN0ciArPSBibG9ja3M7XG4gICAgICAgICAgICBvdXRQb3MgKz0gYmxvY2tCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYXZlIGxlZnRvdmVyc1xuICAgICAgICBjb25zdCBsZWZ0ID0gbGVuIC0gb3V0UG9zO1xuICAgICAgICBpZiAobGVmdCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmLmZpbGwoMCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBjaXBoZXIgd2lsbCBoYW5kbGUgb3ZlcmZsb3dcbiAgICAgICAgICAgIHRoaXMuY2lwaGVyKHRoaXMua2V5LCB0aGlzLm5vbmNlLCB0aGlzLmJ1ZiwgdGhpcy5idWYsIHRoaXMuY3RyKyspO1xuICAgICAgICAgICAgb3V0LnNldCh0aGlzLmJ1Zi5zdWJhcnJheSgwLCBsZWZ0KSwgb3V0UG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfWG9yU3RyZWFtUFJHKHRoaXMuY2lwaGVyLCB0aGlzLmJsb2NrTGVuLCB0aGlzLmtleUxlbiwgdGhpcy5ub25jZUxlbiwgdGhpcy5yYW5kb21CeXRlcyh0aGlzLnN0YXRlLmxlbmd0aCkpO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN0ciA9IDA7XG4gICAgICAgIHRoaXMuYnVmLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgY3JlYXRlUFJHID0gKGNpcGhlciwgYmxvY2tMZW4sIGtleUxlbiwgbm9uY2VMZW4pID0+IHtcbiAgICByZXR1cm4gKHNlZWQgPSByYW5kb21CeXRlcygzMikpID0+IG5ldyBfWG9yU3RyZWFtUFJHKGNpcGhlciwgYmxvY2tMZW4sIGtleUxlbiwgbm9uY2VMZW4sIHNlZWQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hcnguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_arx.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_poly1305.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_poly1305.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Poly1305: () => (/* binding */ Poly1305),\n/* harmony export */   poly1305: () => (/* binding */ poly1305),\n/* harmony export */   wrapConstructorWithKey: () => (/* binding */ wrapConstructorWithKey)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js\");\n/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).\n * @module\n */\n// prettier-ignore\n\nfunction u8to16(a, i) {\n    return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n}\nfunction bytesToNumberLE(bytes) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToNumber)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\n/** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */\nfunction poly1305_small(msg, key) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'key');\n    const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5\n    const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1\n    const CLAMP_R = BigInt('0x0ffffffc0ffffffc0ffffffc0fffffff');\n    const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;\n    const s = bytesToNumberLE(key.subarray(16));\n    // Process by 16 byte chunks\n    let acc = BigInt(0);\n    for (let i = 0; i < msg.length; i += 16) {\n        const m = msg.subarray(i, i + 16);\n        const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));\n        acc = ((acc + n) * r) % POW_2_130_5;\n    }\n    const res = (acc + s) & POW_2_128_1;\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(res, 16).reverse(); // LE\n}\n// Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.\n// @ts-expect-error\nfunction poly1305_computeTag_small(authKey, lengths, ciphertext, AAD) {\n    const res = [];\n    const updatePadded2 = (msg) => {\n        res.push(msg);\n        const leftover = msg.length % 16;\n        if (leftover)\n            res.push(new Uint8Array(16).slice(leftover));\n    };\n    if (AAD)\n        updatePadded2(AAD);\n    updatePadded2(ciphertext);\n    res.push(lengths);\n    return poly1305_small((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...res), authKey);\n}\n/** Poly1305 class. Prefer poly1305() function instead. */\nclass Poly1305 {\n    blockLen = 16;\n    outputLen = 16;\n    buffer = new Uint8Array(16);\n    r = new Uint16Array(10); // Allocating 1 array with .subarray() here is slower than 3\n    h = new Uint16Array(10);\n    pad = new Uint16Array(8);\n    pos = 0;\n    finished = false;\n    // Can be speed-up using BigUint64Array, at the cost of complexity\n    constructor(key) {\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'key'));\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(g);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(data);\n        const { buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update(msg).digest();\n    const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\n/** Poly1305 MAC from RFC 8439. */\nconst poly1305 = /** @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();\n//# sourceMappingURL=_poly1305.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2NpcGhlcnNAMi4wLjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19wb2x5MTMwNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQVcsQ0FBQyxxREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWLDhEQUE4RDtBQUM5RCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMERBQWUscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBVztBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBUyxDQUFDLGlEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsaURBQU07QUFDZCxlQUFlLG9EQUFTO0FBQ3hCLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGtEQUFPO0FBQ2Y7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL25ld3MtaHViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjaXBoZXJzQDIuMC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9fcG9seTEzMDUuanM/NTExMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvbHkxMzA1IChbUERGXShodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGYpLFxuICogW3dpa2ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvbHkxMzA1KSlcbiAqIGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUgc3VpdGFibGUgZm9yXG4gKiBhIHdpZGUgdmFyaWV0eSBvZiBhcHBsaWNhdGlvbnMuIEl0IHdhcyBzdGFuZGFyZGl6ZWQgaW5cbiAqIFtSRkMgODQzOV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzg0MzkpIGFuZCBpcyBub3cgdXNlZCBpbiBUTFMgMS4zLlxuICpcbiAqIFBvbHlub21pYWwgTUFDcyBhcmUgbm90IHBlcmZlY3QgZm9yIGV2ZXJ5IHNpdHVhdGlvbjpcbiAqIHRoZXkgbGFjayBSYW5kb20gS2V5IFJvYnVzdG5lc3M6IHRoZSBNQUMgY2FuIGJlIGZvcmdlZCwgYW5kIGNhbid0IGJlIHVzZWQgaW4gUEFLRSBzY2hlbWVzLlxuICogU2VlIFtpbnZpc2libGUgc2FsYW1hbmRlcnMgYXR0YWNrXShodHRwczovL2tleW1hdGVyaWFsLm5ldC8yMDIwLzA5LzA3L2ludmlzaWJsZS1zYWxhbWFuZGVycy1pbi1hZXMtZ2NtLXNpdi8pLlxuICogVG8gY29tYmF0IGludmlzaWJsZSBzYWxhbWFuZGVycywgYGhhc2goa2V5KWAgY2FuIGJlIGluY2x1ZGVkIGluIGNpcGhlcnRleHQsXG4gKiBob3dldmVyLCB0aGlzIHdvdWxkIHZpb2xhdGUgY2lwaGVydGV4dCBpbmRpc3Rpbmd1aXNoYWJpbGl0eTpcbiAqIGFuIGF0dGFja2VyIHdvdWxkIGtub3cgd2hpY2gga2V5IHdhcyB1c2VkIC0gc28gYEhLREYoa2V5LCBpKWBcbiAqIGNvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiBDaGVjayBvdXQgW29yaWdpbmFsIHdlYnNpdGVdKGh0dHBzOi8vY3IueXAudG8vbWFjLmh0bWwpLlxuICogQmFzZWQgb24gUHVibGljIERvbWFpbiBbcG9seTEzMDUtZG9ubmFdKGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYSkuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBieXRlc1RvSGV4LCBjbGVhbiwgY29uY2F0Qnl0ZXMsIGNvcHlCeXRlcywgaGV4VG9OdW1iZXIsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiB1OHRvMTYoYSwgaSkge1xuICAgIHJldHVybiAoYVtpKytdICYgMHhmZikgfCAoKGFbaSsrXSAmIDB4ZmYpIDw8IDgpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbi8qKiBTbWFsbCB2ZXJzaW9uIG9mIGBwb2x5MTMwNWAgd2l0aG91dCBsb29wIHVucm9sbGluZy4gVW51c2VkLCBwcm92aWRlZCBmb3IgYXVkaXRhYmlsaXR5LiAqL1xuZnVuY3Rpb24gcG9seTEzMDVfc21hbGwobXNnLCBrZXkpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoa2V5LCAzMiwgJ2tleScpO1xuICAgIGNvbnN0IFBPV18yXzEzMF81ID0gQmlnSW50KDIpICoqIEJpZ0ludCgxMzApIC0gQmlnSW50KDUpOyAvLyAyXjEzMC01XG4gICAgY29uc3QgUE9XXzJfMTI4XzEgPSBCaWdJbnQoMikgKiogQmlnSW50KDEyOCkgLSBCaWdJbnQoMSk7IC8vIDJeMTI4LTFcbiAgICBjb25zdCBDTEFNUF9SID0gQmlnSW50KCcweDBmZmZmZmZjMGZmZmZmZmMwZmZmZmZmYzBmZmZmZmZmJyk7XG4gICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJMRShrZXkuc3ViYXJyYXkoMCwgMTYpKSAmIENMQU1QX1I7XG4gICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXJMRShrZXkuc3ViYXJyYXkoMTYpKTtcbiAgICAvLyBQcm9jZXNzIGJ5IDE2IGJ5dGUgY2h1bmtzXG4gICAgbGV0IGFjYyA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgY29uc3QgbSA9IG1zZy5zdWJhcnJheShpLCBpICsgMTYpO1xuICAgICAgICBjb25zdCBuID0gYnl0ZXNUb051bWJlckxFKG0pIHwgKEJpZ0ludCgxKSA8PCBCaWdJbnQoOCAqIG0ubGVuZ3RoKSk7XG4gICAgICAgIGFjYyA9ICgoYWNjICsgbikgKiByKSAlIFBPV18yXzEzMF81O1xuICAgIH1cbiAgICBjb25zdCByZXMgPSAoYWNjICsgcykgJiBQT1dfMl8xMjhfMTtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKHJlcywgMTYpLnJldmVyc2UoKTsgLy8gTEVcbn1cbi8vIENhbiBiZSB1c2VkIHRvIHJlcGxhY2UgYGNvbXB1dGVUYWdgIGluIGNoYWNoYS50cy4gVW51c2VkLCBwcm92aWRlZCBmb3IgYXVkaXRhYmlsaXR5LlxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gcG9seTEzMDVfY29tcHV0ZVRhZ19zbWFsbChhdXRoS2V5LCBsZW5ndGhzLCBjaXBoZXJ0ZXh0LCBBQUQpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVQYWRkZWQyID0gKG1zZykgPT4ge1xuICAgICAgICByZXMucHVzaChtc2cpO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlciA9IG1zZy5sZW5ndGggJSAxNjtcbiAgICAgICAgaWYgKGxlZnRvdmVyKVxuICAgICAgICAgICAgcmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoMTYpLnNsaWNlKGxlZnRvdmVyKSk7XG4gICAgfTtcbiAgICBpZiAoQUFEKVxuICAgICAgICB1cGRhdGVQYWRkZWQyKEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkMihjaXBoZXJ0ZXh0KTtcbiAgICByZXMucHVzaChsZW5ndGhzKTtcbiAgICByZXR1cm4gcG9seTEzMDVfc21hbGwoY29uY2F0Qnl0ZXMoLi4ucmVzKSwgYXV0aEtleSk7XG59XG4vKiogUG9seTEzMDUgY2xhc3MuIFByZWZlciBwb2x5MTMwNSgpIGZ1bmN0aW9uIGluc3RlYWQuICovXG5leHBvcnQgY2xhc3MgUG9seTEzMDUge1xuICAgIGJsb2NrTGVuID0gMTY7XG4gICAgb3V0cHV0TGVuID0gMTY7XG4gICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIHIgPSBuZXcgVWludDE2QXJyYXkoMTApOyAvLyBBbGxvY2F0aW5nIDEgYXJyYXkgd2l0aCAuc3ViYXJyYXkoKSBoZXJlIGlzIHNsb3dlciB0aGFuIDNcbiAgICBoID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgICBwYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gICAgcG9zID0gMDtcbiAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIENhbiBiZSBzcGVlZC11cCB1c2luZyBCaWdVaW50NjRBcnJheSwgYXQgdGhlIGNvc3Qgb2YgY29tcGxleGl0eVxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBrZXkgPSBjb3B5Qnl0ZXMoYWJ5dGVzKGtleSwgMzIsICdrZXknKSk7XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGtleSwgMik7XG4gICAgICAgIGNvbnN0IHQyID0gdTh0bzE2KGtleSwgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGtleSwgOCk7XG4gICAgICAgIGNvbnN0IHQ1ID0gdTh0bzE2KGtleSwgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoa2V5LCAxNCk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYS9ibG9iL2U2YWQ2ZTA5MWQzMGQ3ZjRlYzJkNGY5NzhiZTFmY2ZjYmNlNzI3ODEvcG9seTEzMDUtZG9ubmEtMTYuaCNMNDdcbiAgICAgICAgdGhpcy5yWzBdID0gdDAgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmMDM7XG4gICAgICAgIHRoaXMuclszXSA9ICgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzRdID0gKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgICAgICAgdGhpcy5yWzVdID0gKHQ0ID4+PiAxKSAmIDB4MWZmZTtcbiAgICAgICAgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWY4MTtcbiAgICAgICAgdGhpcy5yWzhdID0gKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbOV0gPSAodDcgPj4+IDUpICYgMHgwMDdmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGFkW2ldID0gdTh0bzE2KGtleSwgMTYgKyAyICogaSk7XG4gICAgfVxuICAgIHByb2Nlc3MoZGF0YSwgb2Zmc2V0LCBpc0xhc3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaWJpdCA9IGlzTGFzdCA/IDAgOiAxIDw8IDExO1xuICAgICAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHIwID0gclswXTtcbiAgICAgICAgY29uc3QgcjEgPSByWzFdO1xuICAgICAgICBjb25zdCByMiA9IHJbMl07XG4gICAgICAgIGNvbnN0IHIzID0gclszXTtcbiAgICAgICAgY29uc3QgcjQgPSByWzRdO1xuICAgICAgICBjb25zdCByNSA9IHJbNV07XG4gICAgICAgIGNvbnN0IHI2ID0gcls2XTtcbiAgICAgICAgY29uc3QgcjcgPSByWzddO1xuICAgICAgICBjb25zdCByOCA9IHJbOF07XG4gICAgICAgIGNvbnN0IHI5ID0gcls5XTtcbiAgICAgICAgY29uc3QgdDAgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgY29uc3QgdDMgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMCk7XG4gICAgICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTQpO1xuICAgICAgICBsZXQgaDAgPSBoWzBdICsgKHQwICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgxID0gaFsxXSArICgoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgyID0gaFsyXSArICgoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgzID0gaFszXSArICgoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDQgPSBoWzRdICsgKCgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDUgPSBoWzVdICsgKCh0NCA+Pj4gMSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDYgPSBoWzZdICsgKCgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDcgPSBoWzddICsgKCgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDggPSBoWzhdICsgKCgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoOSA9IGhbOV0gKyAoKHQ3ID4+PiA1KSB8IGhpYml0KTtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBsZXQgZDAgPSBjICsgaDAgKiByMCArIGgxICogKDUgKiByOSkgKyBoMiAqICg1ICogcjgpICsgaDMgKiAoNSAqIHI3KSArIGg0ICogKDUgKiByNik7XG4gICAgICAgIGMgPSBkMCA+Pj4gMTM7XG4gICAgICAgIGQwICY9IDB4MWZmZjtcbiAgICAgICAgZDAgKz0gaDUgKiAoNSAqIHI1KSArIGg2ICogKDUgKiByNCkgKyBoNyAqICg1ICogcjMpICsgaDggKiAoNSAqIHIyKSArIGg5ICogKDUgKiByMSk7XG4gICAgICAgIGMgKz0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMSA9IGMgKyBoMCAqIHIxICsgaDEgKiByMCArIGgyICogKDUgKiByOSkgKyBoMyAqICg1ICogcjgpICsgaDQgKiAoNSAqIHI3KTtcbiAgICAgICAgYyA9IGQxID4+PiAxMztcbiAgICAgICAgZDEgJj0gMHgxZmZmO1xuICAgICAgICBkMSArPSBoNSAqICg1ICogcjYpICsgaDYgKiAoNSAqIHI1KSArIGg3ICogKDUgKiByNCkgKyBoOCAqICg1ICogcjMpICsgaDkgKiAoNSAqIHIyKTtcbiAgICAgICAgYyArPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuICAgICAgICBjID0gZDIgPj4+IDEzO1xuICAgICAgICBkMiAmPSAweDFmZmY7XG4gICAgICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuICAgICAgICBjICs9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDMgPSBjICsgaDAgKiByMyArIGgxICogcjIgKyBoMiAqIHIxICsgaDMgKiByMCArIGg0ICogKDUgKiByOSk7XG4gICAgICAgIGMgPSBkMyA+Pj4gMTM7XG4gICAgICAgIGQzICY9IDB4MWZmZjtcbiAgICAgICAgZDMgKz0gaDUgKiAoNSAqIHI4KSArIGg2ICogKDUgKiByNykgKyBoNyAqICg1ICogcjYpICsgaDggKiAoNSAqIHI1KSArIGg5ICogKDUgKiByNCk7XG4gICAgICAgIGMgKz0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNCA9IGMgKyBoMCAqIHI0ICsgaDEgKiByMyArIGgyICogcjIgKyBoMyAqIHIxICsgaDQgKiByMDtcbiAgICAgICAgYyA9IGQ0ID4+PiAxMztcbiAgICAgICAgZDQgJj0gMHgxZmZmO1xuICAgICAgICBkNCArPSBoNSAqICg1ICogcjkpICsgaDYgKiAoNSAqIHI4KSArIGg3ICogKDUgKiByNykgKyBoOCAqICg1ICogcjYpICsgaDkgKiAoNSAqIHI1KTtcbiAgICAgICAgYyArPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuICAgICAgICBjID0gZDUgPj4+IDEzO1xuICAgICAgICBkNSAmPSAweDFmZmY7XG4gICAgICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuICAgICAgICBjICs9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDYgPSBjICsgaDAgKiByNiArIGgxICogcjUgKyBoMiAqIHI0ICsgaDMgKiByMyArIGg0ICogcjI7XG4gICAgICAgIGMgPSBkNiA+Pj4gMTM7XG4gICAgICAgIGQ2ICY9IDB4MWZmZjtcbiAgICAgICAgZDYgKz0gaDUgKiByMSArIGg2ICogcjAgKyBoNyAqICg1ICogcjkpICsgaDggKiAoNSAqIHI4KSArIGg5ICogKDUgKiByNyk7XG4gICAgICAgIGMgKz0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNyA9IGMgKyBoMCAqIHI3ICsgaDEgKiByNiArIGgyICogcjUgKyBoMyAqIHI0ICsgaDQgKiByMztcbiAgICAgICAgYyA9IGQ3ID4+PiAxMztcbiAgICAgICAgZDcgJj0gMHgxZmZmO1xuICAgICAgICBkNyArPSBoNSAqIHIyICsgaDYgKiByMSArIGg3ICogcjAgKyBoOCAqICg1ICogcjkpICsgaDkgKiAoNSAqIHI4KTtcbiAgICAgICAgYyArPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuICAgICAgICBjID0gZDggPj4+IDEzO1xuICAgICAgICBkOCAmPSAweDFmZmY7XG4gICAgICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuICAgICAgICBjICs9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDkgPSBjICsgaDAgKiByOSArIGgxICogcjggKyBoMiAqIHI3ICsgaDMgKiByNiArIGg0ICogcjU7XG4gICAgICAgIGMgPSBkOSA+Pj4gMTM7XG4gICAgICAgIGQ5ICY9IDB4MWZmZjtcbiAgICAgICAgZDkgKz0gaDUgKiByNCArIGg2ICogcjMgKyBoNyAqIHIyICsgaDggKiByMSArIGg5ICogcjA7XG4gICAgICAgIGMgKz0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGMgPSAoKGMgPDwgMikgKyBjKSB8IDA7XG4gICAgICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICAgICAgYyA9IGMgPj4+IDEzO1xuICAgICAgICBkMSArPSBjO1xuICAgICAgICBoWzBdID0gZDA7XG4gICAgICAgIGhbMV0gPSBkMTtcbiAgICAgICAgaFsyXSA9IGQyO1xuICAgICAgICBoWzNdID0gZDM7XG4gICAgICAgIGhbNF0gPSBkNDtcbiAgICAgICAgaFs1XSA9IGQ1O1xuICAgICAgICBoWzZdID0gZDY7XG4gICAgICAgIGhbN10gPSBkNztcbiAgICAgICAgaFs4XSA9IGQ4O1xuICAgICAgICBoWzldID0gZDk7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCB7IGgsIHBhZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIGxldCBjID0gaFsxXSA+Pj4gMTM7XG4gICAgICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGhbaV0gKz0gYztcbiAgICAgICAgICAgIGMgPSBoW2ldID4+PiAxMztcbiAgICAgICAgICAgIGhbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGhbMF0gKz0gYyAqIDU7XG4gICAgICAgIGMgPSBoWzBdID4+PiAxMztcbiAgICAgICAgaFswXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMV0gKz0gYztcbiAgICAgICAgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgaFsyXSArPSBjO1xuICAgICAgICBnWzBdID0gaFswXSArIDU7XG4gICAgICAgIGMgPSBnWzBdID4+PiAxMztcbiAgICAgICAgZ1swXSAmPSAweDFmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgZ1tpXSA9IGhbaV0gKyBjO1xuICAgICAgICAgICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgICAgICAgICAgZ1tpXSAmPSAweDFmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZ1s5XSAtPSAxIDw8IDEzO1xuICAgICAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBnW2ldICY9IG1hc2s7XG4gICAgICAgIG1hc2sgPSB+bWFzaztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgaFtpXSA9IChoW2ldICYgbWFzaykgfCBnW2ldO1xuICAgICAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuICAgICAgICBoWzFdID0gKChoWzFdID4+PiAzKSB8IChoWzJdIDw8IDEwKSkgJiAweGZmZmY7XG4gICAgICAgIGhbMl0gPSAoKGhbMl0gPj4+IDYpIHwgKGhbM10gPDwgNykpICYgMHhmZmZmO1xuICAgICAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs0XSA9ICgoaFs0XSA+Pj4gMTIpIHwgKGhbNV0gPDwgMSkgfCAoaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICAgICAgICBoWzVdID0gKChoWzZdID4+PiAyKSB8IChoWzddIDw8IDExKSkgJiAweGZmZmY7XG4gICAgICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuICAgICAgICBoWzddID0gKChoWzhdID4+PiA4KSB8IChoWzldIDw8IDUpKSAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGYgPSBoWzBdICsgcGFkWzBdO1xuICAgICAgICBoWzBdID0gZiAmIDB4ZmZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGYgPSAoKChoW2ldICsgcGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgICAgICAgICAgaFtpXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW4oZyk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgZGF0YSA9IGNvcHlCeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0XG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhLCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbih0aGlzLmgsIHRoaXMuciwgdGhpcy5idWZmZXIsIHRoaXMucGFkKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGggfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgYnVmZmVyW3BvcysrXSA9IDE7XG4gICAgICAgICAgICBmb3IgKDsgcG9zIDwgMTY7IHBvcysrKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltwb3NdID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhidWZmZXIsIDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgbGV0IG9wb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiAwO1xuICAgICAgICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aEtleShoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywga2V5KSA9PiBoYXNoQ29ucyhrZXkpLnVwZGF0ZShtc2cpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKG5ldyBVaW50OEFycmF5KDMyKSk7IC8vIHRtcCBhcnJheSwgdXNlZCBqdXN0IG9uY2UgYmVsb3dcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChrZXkpID0+IGhhc2hDb25zKGtleSk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqIFBvbHkxMzA1IE1BQyBmcm9tIFJGQyA4NDM5LiAqL1xuZXhwb3J0IGNvbnN0IHBvbHkxMzA1ID0gLyoqIEBfX1BVUkVfXyAqLyAoKCkgPT4gd3JhcENvbnN0cnVjdG9yV2l0aEtleSgoa2V5KSA9PiBuZXcgUG9seTEzMDUoa2V5KSkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcG9seTEzMDUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_poly1305.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/chacha.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/chacha.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _poly1305_aead: () => (/* binding */ _poly1305_aead),\n/* harmony export */   chacha12: () => (/* binding */ chacha12),\n/* harmony export */   chacha20: () => (/* binding */ chacha20),\n/* harmony export */   chacha20orig: () => (/* binding */ chacha20orig),\n/* harmony export */   chacha20poly1305: () => (/* binding */ chacha20poly1305),\n/* harmony export */   chacha8: () => (/* binding */ chacha8),\n/* harmony export */   hchacha: () => (/* binding */ hchacha),\n/* harmony export */   rngChacha20: () => (/* binding */ rngChacha20),\n/* harmony export */   rngChacha8: () => (/* binding */ rngChacha8),\n/* harmony export */   xchacha20: () => (/* binding */ xchacha20),\n/* harmony export */   xchacha20poly1305: () => (/* binding */ xchacha20poly1305)\n/* harmony export */ });\n/* harmony import */ var _arx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arx.js */ \"(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_arx.js\");\n/* harmony import */ var _poly1305_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_poly1305.js */ \"(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/_poly1305.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js\");\n/**\n * ChaCha stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20) and\n * [website](https://cr.yp.to/chacha.html).\n *\n * @module\n */\n\n\n\n/**\n * ChaCha core function. It is implemented twice:\n * 1. Simple loop (chachaCore_small, hchacha_small)\n * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read\n * The specific implementation is selected in `createCipher` below.\n */\n/** quarter-round */\n// prettier-ignore\nfunction chachaQR(x, a, b, c, d) {\n    x[a] = (x[a] + x[b]) | 0;\n    x[d] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[d] ^ x[a], 16);\n    x[c] = (x[c] + x[d]) | 0;\n    x[b] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[b] ^ x[c], 12);\n    x[a] = (x[a] + x[b]) | 0;\n    x[d] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[d] ^ x[a], 8);\n    x[c] = (x[c] + x[d]) | 0;\n    x[b] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[b] ^ x[c], 7);\n}\n/** single round */\nfunction chachaRound(x, rounds = 20) {\n    for (let r = 0; r < rounds; r += 2) {\n        chachaQR(x, 0, 4, 8, 12);\n        chachaQR(x, 1, 5, 9, 13);\n        chachaQR(x, 2, 6, 10, 14);\n        chachaQR(x, 3, 7, 11, 15);\n        chachaQR(x, 0, 5, 10, 15);\n        chachaQR(x, 1, 6, 11, 12);\n        chachaQR(x, 2, 7, 8, 13);\n        chachaQR(x, 3, 4, 9, 14);\n    }\n}\nconst ctmp = /* @__PURE__ */ new Uint32Array(16);\n/** Small version of chacha without loop unrolling. Unused, provided for auditability. */\n// prettier-ignore\nfunction chacha(s, k, i, out, isHChacha = true, rounds = 20) {\n    // Create initial array using common pattern\n    const y = Uint32Array.from([\n        s[0], s[1], s[2], s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n        k[0], k[1], k[2], k[3], // Key      Key     Key     Key\n        k[4], k[5], k[6], k[7], // Key      Key     Key     Key\n        i[0], i[1], i[2], i[3], // Counter  Counter Nonce   Nonce\n    ]);\n    const x = ctmp;\n    x.set(y);\n    chachaRound(x, rounds);\n    // hchacha extracts 8 specific bytes, chacha adds orig to result\n    if (isHChacha) {\n        const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];\n        for (let i = 0; i < 8; i++)\n            out[i] = x[xindexes[i]];\n    }\n    else {\n        for (let i = 0; i < 16; i++)\n            out[i] = (y[i] + x[i]) | 0;\n    }\n}\n/** Identical to `chachaCore`. Unused. */\n// @ts-ignore\nconst chachaCore_small = (s, k, n, out, cnt, rounds) => chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);\n/** Identical to `hchacha`. Unused. */\n// @ts-ignore\nconst hchacha_small = chacha;\n/** Identical to `chachaCore_small`. Unused. */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha hashes key and nonce into key' and nonce' for xchacha20.\n * Identical to `hchacha_small`.\n * Need to find a way to merge it with `chachaCore` without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(s, k, i, out) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    out[oi++] = x00;\n    out[oi++] = x01;\n    out[oi++] = x02;\n    out[oi++] = x03;\n    out[oi++] = x12;\n    out[oi++] = x13;\n    out[oi++] = x14;\n    out[oi++] = x15;\n}\n/** Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter. */\nconst chacha20orig = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With smaller nonce, it's not safe to make it random (CSPRNG), due to collision chance.\n */\nconst chacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. With 24-byte nonce, it's safe to make it random (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nconst xchacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/** Reduced 8-round chacha, described in original paper. */\nconst chacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/** Reduced 12-round chacha, described in original paper. */\nconst chacha12 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const leftover = msg.length % 16;\n    if (leftover)\n        h.update(ZEROS16.subarray(leftover));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, ciphertext, AAD) {\n    if (AAD !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(AAD, undefined, 'AAD');\n    const authKey = fn(key, nonce, ZEROS32);\n    const lengths = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u64Lengths)(ciphertext.length, AAD ? AAD.length : 0, true);\n    // Methods below can be replaced with\n    // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)\n    const h = _poly1305_js__WEBPACK_IMPORTED_MODULE_2__.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, ciphertext);\n    h.update(lengths);\n    const res = h.digest();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(authKey, lengths);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them, but it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    return {\n        encrypt(plaintext, output) {\n            const plength = plaintext.length;\n            output = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOutput)(plength + tagLength, output, false);\n            output.set(plaintext);\n            const oPlain = output.subarray(0, -tagLength);\n            // Actual encryption\n            xorStream(key, nonce, oPlain, oPlain, 1);\n            const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n            output.set(tag, plength); // append tag\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(tag);\n            return output;\n        },\n        decrypt(ciphertext, output) {\n            output = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOutput)(ciphertext.length - tagLength, output, false);\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            output.set(ciphertext.subarray(0, -tagLength));\n            // Actual decryption\n            xorStream(key, nonce, output, output, 1); // start stream with i=1\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(tag);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nconst chacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nconst xchacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n/**\n * Chacha20 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Compatible with libtomcrypt. It does not have a specification, so unclear how secure it is.\n */\nconst rngChacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createPRG)(chacha20orig, 64, 32, 8);\n/**\n * Chacha20/8 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Faster than `rngChacha20`.\n */\nconst rngChacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createPRG)(chacha8, 64, 32, 12);\n//# sourceMappingURL=chacha.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2NpcGhlcnNAMi4wLjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2NoYWNoYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQ2hCO0FBQ2lEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBSTtBQUNmO0FBQ0EsV0FBVyw2Q0FBSTtBQUNmO0FBQ0EsV0FBVyw2Q0FBSTtBQUNmO0FBQ0EsV0FBVyw2Q0FBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDLHFEQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxxREFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MscURBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTyxnQ0FBZ0MscURBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ08saUNBQWlDLHFEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLGtEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFlBQVksZ0RBQUs7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUIsb0RBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxZQUFZLGdEQUFLO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMscURBQVUsR0FBRywrQ0FBK0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHFEQUFVLEdBQUcsK0NBQStDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQ0FBb0Msa0RBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyxrREFBUztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL25ld3MtaHViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjaXBoZXJzQDIuMC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9jaGFjaGEuanM/MTRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLCByZWxlYXNlZFxuICogaW4gMjAwOC4gRGV2ZWxvcGVkIGFmdGVyIFNhbHNhMjAsIENoYUNoYSBhaW1zIHRvIGluY3JlYXNlIGRpZmZ1c2lvbiBwZXIgcm91bmQuXG4gKiBJdCB3YXMgc3RhbmRhcmRpemVkIGluIFtSRkMgODQzOV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzg0MzkpIGFuZFxuICogaXMgbm93IHVzZWQgaW4gVExTIDEuMy5cbiAqXG4gKiBbWENoYUNoYTIwXShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhKVxuICogZXh0ZW5kZWQtbm9uY2UgdmFyaWFudCBpcyBhbHNvIHByb3ZpZGVkLiBTaW1pbGFyIHRvIFhTYWxzYSwgaXQncyBzYWZlIHRvIHVzZSB3aXRoXG4gKiByYW5kb21seS1nZW5lcmF0ZWQgbm9uY2VzLlxuICpcbiAqIENoZWNrIG91dCBbUERGXShodHRwOi8vY3IueXAudG8vY2hhY2hhL2NoYWNoYS0yMDA4MDEyOC5wZGYpIGFuZFxuICogW3dpa2ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhbHNhMjApIGFuZFxuICogW3dlYnNpdGVdKGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwpLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgY3JlYXRlQ2lwaGVyLCBjcmVhdGVQUkcsIHJvdGwgfSBmcm9tIFwiLi9fYXJ4LmpzXCI7XG5pbXBvcnQgeyBwb2x5MTMwNSB9IGZyb20gXCIuL19wb2x5MTMwNS5qc1wiO1xuaW1wb3J0IHsgYWJ5dGVzLCBjbGVhbiwgZXF1YWxCeXRlcywgZ2V0T3V0cHV0LCB1NjRMZW5ndGhzLCB3cmFwQ2lwaGVyLCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIENoYUNoYSBjb3JlIGZ1bmN0aW9uLiBJdCBpcyBpbXBsZW1lbnRlZCB0d2ljZTpcbiAqIDEuIFNpbXBsZSBsb29wIChjaGFjaGFDb3JlX3NtYWxsLCBoY2hhY2hhX3NtYWxsKVxuICogMi4gVW5yb2xsZWQgbG9vcCAoY2hhY2hhQ29yZSwgaGNoYWNoYSkgLSA0eCBmYXN0ZXIsIGJ1dCBsYXJnZXIgJiBoYXJkZXIgdG8gcmVhZFxuICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGlzIHNlbGVjdGVkIGluIGBjcmVhdGVDaXBoZXJgIGJlbG93LlxuICovXG4vKiogcXVhcnRlci1yb3VuZCAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFRUih4LCBhLCBiLCBjLCBkKSB7XG4gICAgeFthXSA9ICh4W2FdICsgeFtiXSkgfCAwO1xuICAgIHhbZF0gPSByb3RsKHhbZF0gXiB4W2FdLCAxNik7XG4gICAgeFtjXSA9ICh4W2NdICsgeFtkXSkgfCAwO1xuICAgIHhbYl0gPSByb3RsKHhbYl0gXiB4W2NdLCAxMik7XG4gICAgeFthXSA9ICh4W2FdICsgeFtiXSkgfCAwO1xuICAgIHhbZF0gPSByb3RsKHhbZF0gXiB4W2FdLCA4KTtcbiAgICB4W2NdID0gKHhbY10gKyB4W2RdKSB8IDA7XG4gICAgeFtiXSA9IHJvdGwoeFtiXSBeIHhbY10sIDcpO1xufVxuLyoqIHNpbmdsZSByb3VuZCAqL1xuZnVuY3Rpb24gY2hhY2hhUm91bmQoeCwgcm91bmRzID0gMjApIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHJvdW5kczsgciArPSAyKSB7XG4gICAgICAgIGNoYWNoYVFSKHgsIDAsIDQsIDgsIDEyKTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMSwgNSwgOSwgMTMpO1xuICAgICAgICBjaGFjaGFRUih4LCAyLCA2LCAxMCwgMTQpO1xuICAgICAgICBjaGFjaGFRUih4LCAzLCA3LCAxMSwgMTUpO1xuICAgICAgICBjaGFjaGFRUih4LCAwLCA1LCAxMCwgMTUpO1xuICAgICAgICBjaGFjaGFRUih4LCAxLCA2LCAxMSwgMTIpO1xuICAgICAgICBjaGFjaGFRUih4LCAyLCA3LCA4LCAxMyk7XG4gICAgICAgIGNoYWNoYVFSKHgsIDMsIDQsIDksIDE0KTtcbiAgICB9XG59XG5jb25zdCBjdG1wID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgxNik7XG4vKiogU21hbGwgdmVyc2lvbiBvZiBjaGFjaGEgd2l0aG91dCBsb29wIHVucm9sbGluZy4gVW51c2VkLCBwcm92aWRlZCBmb3IgYXVkaXRhYmlsaXR5LiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGEocywgaywgaSwgb3V0LCBpc0hDaGFjaGEgPSB0cnVlLCByb3VuZHMgPSAyMCkge1xuICAgIC8vIENyZWF0ZSBpbml0aWFsIGFycmF5IHVzaW5nIGNvbW1vbiBwYXR0ZXJuXG4gICAgY29uc3QgeSA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgICAgICBzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICAgICAga1swXSwga1sxXSwga1syXSwga1szXSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgICAgICBrWzRdLCBrWzVdLCBrWzZdLCBrWzddLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgICAgIGlbMF0sIGlbMV0sIGlbMl0sIGlbM10sIC8vIENvdW50ZXIgIENvdW50ZXIgTm9uY2UgICBOb25jZVxuICAgIF0pO1xuICAgIGNvbnN0IHggPSBjdG1wO1xuICAgIHguc2V0KHkpO1xuICAgIGNoYWNoYVJvdW5kKHgsIHJvdW5kcyk7XG4gICAgLy8gaGNoYWNoYSBleHRyYWN0cyA4IHNwZWNpZmljIGJ5dGVzLCBjaGFjaGEgYWRkcyBvcmlnIHRvIHJlc3VsdFxuICAgIGlmIChpc0hDaGFjaGEpIHtcbiAgICAgICAgY29uc3QgeGluZGV4ZXMgPSBbMCwgMSwgMiwgMywgMTIsIDEzLCAxNCwgMTVdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIG91dFtpXSA9IHhbeGluZGV4ZXNbaV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICAgICAgb3V0W2ldID0gKHlbaV0gKyB4W2ldKSB8IDA7XG4gICAgfVxufVxuLyoqIElkZW50aWNhbCB0byBgY2hhY2hhQ29yZWAuIFVudXNlZC4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNoYWNoYUNvcmVfc21hbGwgPSAocywgaywgbiwgb3V0LCBjbnQsIHJvdW5kcykgPT4gY2hhY2hhKHMsIGssIFVpbnQzMkFycmF5LmZyb20oW25bMF0sIG5bMV0sIGNudCwgMF0pLCBvdXQsIGZhbHNlLCByb3VuZHMpO1xuLyoqIElkZW50aWNhbCB0byBgaGNoYWNoYWAuIFVudXNlZC4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGhjaGFjaGFfc21hbGwgPSBjaGFjaGE7XG4vKiogSWRlbnRpY2FsIHRvIGBjaGFjaGFDb3JlX3NtYWxsYC4gVW51c2VkLiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBzWzBdLCB5MDEgPSBzWzFdLCB5MDIgPSBzWzJdLCB5MDMgPSBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoYXNoZXMga2V5IGFuZCBub25jZSBpbnRvIGtleScgYW5kIG5vbmNlJyBmb3IgeGNoYWNoYTIwLlxuICogSWRlbnRpY2FsIHRvIGBoY2hhY2hhX3NtYWxsYC5cbiAqIE5lZWQgdG8gZmluZCBhIHdheSB0byBtZXJnZSBpdCB3aXRoIGBjaGFjaGFDb3JlYCB3aXRob3V0IDI1JSBwZXJmb3JtYW5jZSBoaXQuXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGhjaGFjaGEocywgaywgaSwgb3V0KSB7XG4gICAgbGV0IHgwMCA9IHNbMF0sIHgwMSA9IHNbMV0sIHgwMiA9IHNbMl0sIHgwMyA9IHNbM10sIHgwNCA9IGtbMF0sIHgwNSA9IGtbMV0sIHgwNiA9IGtbMl0sIHgwNyA9IGtbM10sIHgwOCA9IGtbNF0sIHgwOSA9IGtbNV0sIHgxMCA9IGtbNl0sIHgxMSA9IGtbN10sIHgxMiA9IGlbMF0sIHgxMyA9IGlbMV0sIHgxNCA9IGlbMl0sIHgxNSA9IGlbM107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAyMDsgciArPSAyKSB7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDAsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSByb3RsKHgwNCBeIHgwOCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSByb3RsKHgwNCBeIHgwOCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDEsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSByb3RsKHgwNSBeIHgwOSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSByb3RsKHgwNSBeIHgwOSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDIsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSByb3RsKHgwNiBeIHgxMCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSByb3RsKHgwNiBeIHgxMCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSByb3RsKHgwNyBeIHgxMSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSByb3RsKHgwNyBeIHgxMSwgNyk7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSByb3RsKHgwNSBeIHgxMCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSByb3RsKHgwNSBeIHgxMCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDEsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSByb3RsKHgwNiBeIHgxMSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSByb3RsKHgwNiBeIHgxMSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDIsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSByb3RsKHgwNyBeIHgwOCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSByb3RsKHgwNyBeIHgwOCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDMsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSByb3RsKHgwNCBeIHgwOSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSByb3RsKHgwNCBeIHgwOSwgNyk7XG4gICAgfVxuICAgIGxldCBvaSA9IDA7XG4gICAgb3V0W29pKytdID0geDAwO1xuICAgIG91dFtvaSsrXSA9IHgwMTtcbiAgICBvdXRbb2krK10gPSB4MDI7XG4gICAgb3V0W29pKytdID0geDAzO1xuICAgIG91dFtvaSsrXSA9IHgxMjtcbiAgICBvdXRbb2krK10gPSB4MTM7XG4gICAgb3V0W29pKytdID0geDE0O1xuICAgIG91dFtvaSsrXSA9IHgxNTtcbn1cbi8qKiBPcmlnaW5hbCwgbm9uLVJGQyBjaGFjaGEyMCBmcm9tIERKQi4gOC1ieXRlIG5vbmNlLCA4LWJ5dGUgY291bnRlci4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGEyMG9yaWcgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgYWxsb3dTaG9ydEtleXM6IHRydWUsXG59KTtcbi8qKlxuICogQ2hhQ2hhIHN0cmVhbSBjaXBoZXIuIENvbmZvcm1zIHRvIFJGQyA4NDM5IChJRVRGLCBUTFMpLiAxMi1ieXRlIG5vbmNlLCA0LWJ5dGUgY291bnRlci5cbiAqIFdpdGggc21hbGxlciBub25jZSwgaXQncyBub3Qgc2FmZSB0byBtYWtlIGl0IHJhbmRvbSAoQ1NQUk5HKSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGEyMCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIFdpdGggMjQtYnl0ZSBub25jZSwgaXQncyBzYWZlIHRvIG1ha2UgaXQgcmFuZG9tIChDU1BSTkcpLlxuICogU2VlIFtJUlRGIGRyYWZ0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHhjaGFjaGEyMCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogOCxcbiAgICBleHRlbmROb25jZUZuOiBoY2hhY2hhLFxuICAgIGFsbG93U2hvcnRLZXlzOiBmYWxzZSxcbn0pO1xuLyoqIFJlZHVjZWQgOC1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGE4ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogOCxcbn0pO1xuLyoqIFJlZHVjZWQgMTItcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMTIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgcm91bmRzOiAxMixcbn0pO1xuY29uc3QgWkVST1MxNiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgxNik7XG4vLyBQYWQgdG8gZGlnZXN0IHNpemUgd2l0aCB6ZXJvc1xuY29uc3QgdXBkYXRlUGFkZGVkID0gKGgsIG1zZykgPT4ge1xuICAgIGgudXBkYXRlKG1zZyk7XG4gICAgY29uc3QgbGVmdG92ZXIgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnRvdmVyKVxuICAgICAgICBoLnVwZGF0ZShaRVJPUzE2LnN1YmFycmF5KGxlZnRvdmVyKSk7XG59O1xuY29uc3QgWkVST1MzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgzMik7XG5mdW5jdGlvbiBjb21wdXRlVGFnKGZuLCBrZXksIG5vbmNlLCBjaXBoZXJ0ZXh0LCBBQUQpIHtcbiAgICBpZiAoQUFEICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFieXRlcyhBQUQsIHVuZGVmaW5lZCwgJ0FBRCcpO1xuICAgIGNvbnN0IGF1dGhLZXkgPSBmbihrZXksIG5vbmNlLCBaRVJPUzMyKTtcbiAgICBjb25zdCBsZW5ndGhzID0gdTY0TGVuZ3RocyhjaXBoZXJ0ZXh0Lmxlbmd0aCwgQUFEID8gQUFELmxlbmd0aCA6IDAsIHRydWUpO1xuICAgIC8vIE1ldGhvZHMgYmVsb3cgY2FuIGJlIHJlcGxhY2VkIHdpdGhcbiAgICAvLyByZXR1cm4gcG9seTEzMDVfY29tcHV0ZVRhZ19zbWFsbChhdXRoS2V5LCBsZW5ndGhzLCBjaXBoZXJ0ZXh0LCBBQUQpXG4gICAgY29uc3QgaCA9IHBvbHkxMzA1LmNyZWF0ZShhdXRoS2V5KTtcbiAgICBpZiAoQUFEKVxuICAgICAgICB1cGRhdGVQYWRkZWQoaCwgQUFEKTtcbiAgICB1cGRhdGVQYWRkZWQoaCwgY2lwaGVydGV4dCk7XG4gICAgaC51cGRhdGUobGVuZ3Rocyk7XG4gICAgY29uc3QgcmVzID0gaC5kaWdlc3QoKTtcbiAgICBjbGVhbihhdXRoS2V5LCBsZW5ndGhzKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBBRUFEIGFsZ29yaXRobSBmcm9tIFJGQyA4NDM5LlxuICogU2Fsc2EyMCBhbmQgY2hhY2hhIChSRkMgODQzOSkgdXNlIHBvbHkxMzA1IGRpZmZlcmVudGx5LlxuICogV2UgY291bGQgaGF2ZSBjb21wb3NlZCB0aGVtLCBidXQgaXQncyBoYXJkIGJlY2F1c2Ugb2YgYXV0aEtleTpcbiAqIEluIHNhbHNhMjAsIGF1dGhLZXkgY2hhbmdlcyBwb3NpdGlvbiBpbiBzYWxzYSBzdHJlYW0uXG4gKiBJbiBjaGFjaGEsIGF1dGhLZXkgY2FuJ3QgYmUgY29tcHV0ZWQgaW5zaWRlIGNvbXB1dGVUYWcsIGl0IG1vZGlmaWVzIHRoZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgX3BvbHkxMzA1X2FlYWQgPSAoeG9yU3RyZWFtKSA9PiAoa2V5LCBub25jZSwgQUFEKSA9PiB7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdChwbGFpbnRleHQsIG91dHB1dCkge1xuICAgICAgICAgICAgY29uc3QgcGxlbmd0aCA9IHBsYWludGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBvdXRwdXQgPSBnZXRPdXRwdXQocGxlbmd0aCArIHRhZ0xlbmd0aCwgb3V0cHV0LCBmYWxzZSk7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KHBsYWludGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvUGxhaW4gPSBvdXRwdXQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICAvLyBBY3R1YWwgZW5jcnlwdGlvblxuICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIG9QbGFpbiwgb1BsYWluLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBvUGxhaW4sIEFBRCk7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KHRhZywgcGxlbmd0aCk7IC8vIGFwcGVuZCB0YWdcbiAgICAgICAgICAgIGNsZWFuKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIG91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gZ2V0T3V0cHV0KGNpcGhlcnRleHQubGVuZ3RoIC0gdGFnTGVuZ3RoLCBvdXRwdXQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcGFzc2VkVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBkYXRhLCBBQUQpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKHBhc3NlZFRhZywgdGFnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnJyk7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCkpO1xuICAgICAgICAgICAgLy8gQWN0dWFsIGRlY3J5cHRpb25cbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBvdXRwdXQsIG91dHB1dCwgMSk7IC8vIHN0YXJ0IHN0cmVhbSB3aXRoIGk9MVxuICAgICAgICAgICAgY2xlYW4odGFnKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4vKipcbiAqIENoYUNoYTIwLVBvbHkxMzA1IGZyb20gUkZDIDg0MzkuXG4gKlxuICogVW5zYWZlIHRvIHVzZSByYW5kb20gbm9uY2VzIHVuZGVyIHRoZSBzYW1lIGtleSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG4gKiBQcmVmZXIgWENoYUNoYSBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBwb2x5MTMwNSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDEyLCB0YWdMZW5ndGg6IDE2IH0sIF9wb2x5MTMwNV9hZWFkKGNoYWNoYTIwKSk7XG4vKipcbiAqIFhDaGFDaGEyMC1Qb2x5MTMwNSBleHRlbmRlZC1ub25jZSBjaGFjaGEuXG4gKlxuICogQ2FuIGJlIHNhZmVseSB1c2VkIHdpdGggcmFuZG9tIG5vbmNlcyAoQ1NQUk5HKS5cbiAqIFNlZSBbSVJURiBkcmFmdF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSkuXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjBwb2x5MTMwNSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDI0LCB0YWdMZW5ndGg6IDE2IH0sIF9wb2x5MTMwNV9hZWFkKHhjaGFjaGEyMCkpO1xuLyoqXG4gKiBDaGFjaGEyMCBDU1BSTkcgKGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvcikuXG4gKiBJdCdzIGJlc3QgdG8gbGltaXQgdXNhZ2UgdG8gbm9uLXByb2R1Y3Rpb24sIG5vbi1jcml0aWNhbCBjYXNlczogZm9yIGV4YW1wbGUsIHRlc3Qtb25seS5cbiAqIENvbXBhdGlibGUgd2l0aCBsaWJ0b21jcnlwdC4gSXQgZG9lcyBub3QgaGF2ZSBhIHNwZWNpZmljYXRpb24sIHNvIHVuY2xlYXIgaG93IHNlY3VyZSBpdCBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHJuZ0NoYWNoYTIwID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVBSRyhjaGFjaGEyMG9yaWcsIDY0LCAzMiwgOCk7XG4vKipcbiAqIENoYWNoYTIwLzggQ1NQUk5HIChjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLlxuICogSXQncyBiZXN0IHRvIGxpbWl0IHVzYWdlIHRvIG5vbi1wcm9kdWN0aW9uLCBub24tY3JpdGljYWwgY2FzZXM6IGZvciBleGFtcGxlLCB0ZXN0LW9ubHkuXG4gKiBGYXN0ZXIgdGhhbiBgcm5nQ2hhY2hhMjBgLlxuICovXG5leHBvcnQgY29uc3Qgcm5nQ2hhY2hhOCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVQUkcoY2hhY2hhOCwgNjQsIDMyLCAxMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFjaGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/chacha.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   complexOverlapBytes: () => (/* binding */ complexOverlapBytes),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   getOutput: () => (/* binding */ getOutput),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isAligned32: () => (/* binding */ isAligned32),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   managedNonce: () => (/* binding */ managedNonce),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   overlapBytes: () => (/* binding */ overlapBytes),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u64Lengths: () => (/* binding */ u64Lengths),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapCipher: () => (/* binding */ wrapCipher)\n/* harmony export */ });\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is boolean. */\nfunction abool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out, undefined, 'output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// Used in micro\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\n// Used in micro, ff1\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nfunction overlapBytes(a, b) {\n    return (a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n    );\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nfunction complexOverlapBytes(input, output) {\n    // This is very cursed. It works somehow, but I'm completely unsure,\n    // reasoning about overlapping aligned windows is very hard.\n    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n        throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Compares 2 uint8array-s in kinda constant time. */\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nconst wrapCipher = (params, constructor) => {\n    function wrappedCipher(key, ...args) {\n        // Validate key\n        abytes(key, undefined, 'key');\n        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n        if (!isLE)\n            throw new Error('Non little-endian hardware is not yet supported');\n        // Validate nonce if nonceLength is present\n        if (params.nonceLength !== undefined) {\n            const nonce = args[0];\n            abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, 'nonce');\n        }\n        // Validate AAD if tagLength present\n        const tagl = params.tagLength;\n        if (tagl && args[1] !== undefined)\n            abytes(args[1], undefined, 'AAD');\n        const cipher = constructor(key, ...args);\n        const checkOutput = (fnLength, output) => {\n            if (output !== undefined) {\n                if (fnLength !== 2)\n                    throw new Error('cipher output not supported');\n                abytes(output, undefined, 'output');\n            }\n        };\n        // Create wrapped cipher with validation and single-use encryption\n        let called = false;\n        const wrCipher = {\n            encrypt(data, output) {\n                if (called)\n                    throw new Error('cannot encrypt() twice with same key + nonce');\n                called = true;\n                abytes(data);\n                checkOutput(cipher.encrypt.length, output);\n                return cipher.encrypt(data, output);\n            },\n            decrypt(data, output) {\n                abytes(data);\n                if (tagl && data.length < tagl)\n                    throw new Error('\"ciphertext\" expected length bigger than tagLength=' + tagl);\n                checkOutput(cipher.decrypt.length, output);\n                return cipher.decrypt(data, output);\n            },\n        };\n        return wrCipher;\n    }\n    Object.assign(wrappedCipher, params);\n    return wrappedCipher;\n};\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nfunction getOutput(expectedLength, out, onlyAligned = true) {\n    if (out === undefined)\n        return new Uint8Array(expectedLength);\n    if (out.length !== expectedLength)\n        throw new Error('\"output\" expected Uint8Array of length ' + expectedLength + ', got: ' + out.length);\n    if (onlyAligned && !isAligned32(out))\n        throw new Error('invalid output, must be aligned');\n    return out;\n}\nfunction u64Lengths(dataLength, aadLength, isLE) {\n    abool(isLE);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    view.setBigUint64(0, BigInt(aadLength), isLE);\n    view.setBigUint64(8, BigInt(dataLength), isLE);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nfunction copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * For `encrypt`, a `nonceBytes`-length buffer is fetched from CSPRNG and\n * prepended to encrypted ciphertext. For `decrypt`, first `nonceBytes` of ciphertext\n * are treated as nonce.\n *\n * NOTE: Under the same key, using random nonces (e.g. `managedNonce`) with AES-GCM and ChaCha\n * should be limited to `2**23` (8M) messages to get a collision chance of `2**-50`. Stretching to  * `2**32` (4B) messages, chance would become `2**-33` - still negligible, but creeping up.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nfunction managedNonce(fn, randomBytes_ = randomBytes) {\n    const { nonceLength } = fn;\n    anumber(nonceLength);\n    const addNonce = (nonce, ciphertext) => {\n        const out = concatBytes(nonce, ciphertext);\n        ciphertext.fill(0);\n        return out;\n    };\n    // NOTE: we cannot support DST here, it would be mistake:\n    // - we don't know how much dst length cipher requires\n    // - nonce may unalign dst and break everything\n    // - we create new u8a anyway (concatBytes)\n    // - previously we passed all args to cipher, but that was mistake!\n    return ((key, ...args) => ({\n        encrypt(plaintext) {\n            abytes(plaintext);\n            const nonce = randomBytes_(nonceLength);\n            const encrypted = fn(key, nonce, ...args).encrypt(plaintext);\n            // @ts-ignore\n            if (encrypted instanceof Promise)\n                return encrypted.then((ct) => addNonce(nonce, ct));\n            return addNonce(nonce, encrypted);\n        },\n        decrypt(ciphertext) {\n            abytes(ciphertext);\n            const nonce = ciphertext.subarray(0, nonceLength);\n            const decrypted = ciphertext.subarray(nonceLength);\n            return fn(key, nonce, ...args).decrypt(decrypted);\n        },\n    }));\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2NpcGhlcnNAMi4wLjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDLCtDQUErQyxPQUFPO0FBQ3RELHNDQUFzQyxJQUFJLFlBQVksYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25ld3MtaHViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjaXBoZXJzQDIuMC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy91dGlscy5qcz8wMjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jaXBoZXJzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGJvb2xlYW4uICovXG5leHBvcnQgZnVuY3Rpb24gYWJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXModmFsdWUsIGxlbmd0aCwgdGl0bGUgPSAnJykge1xuICAgIGNvbnN0IGJ5dGVzID0gaXNCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgbGVuID0gdmFsdWU/Lmxlbmd0aDtcbiAgICBjb25zdCBuZWVkc0xlbiA9IGxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIGlmICghYnl0ZXMgfHwgKG5lZWRzTGVuICYmIGxlbiAhPT0gbGVuZ3RoKSkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgICAgIGNvbnN0IG9mTGVuID0gbmVlZHNMZW4gPyBgIG9mIGxlbmd0aCAke2xlbmd0aH1gIDogJyc7XG4gICAgICAgIGNvbnN0IGdvdCA9IGJ5dGVzID8gYGxlbmd0aD0ke2xlbn1gIDogYHR5cGU9JHt0eXBlb2YgdmFsdWV9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBVaW50OEFycmF5JyArIG9mTGVuICsgJywgZ290ICcgKyBnb3QpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0LCB1bmRlZmluZWQsICdvdXRwdXQnKTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0IGNvbnN0IGlzTEUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFVzZWQgaW4gbWljcm9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiAnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gVXNlZCBpbiBmZjFcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG4vLyBVc2VkIGluIG1pY3JvLCBmZjFcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgobmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28gVThBIHVzZSBzYW1lIHVuZGVybHlpbmcgYnVmZmVyIGFuZCBvdmVybGFwcy5cbiAqIFRoaXMgaXMgaW52YWxpZCBhbmQgY2FuIGNvcnJ1cHQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG92ZXJsYXBCeXRlcyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLmJ1ZmZlciA9PT0gYi5idWZmZXIgJiYgLy8gYmVzdCB3ZSBjYW4gZG8sIG1heSBmYWlsIHdpdGggYW4gb2JzY3VyZSBQcm94eVxuICAgICAgICBhLmJ5dGVPZmZzZXQgPCBiLmJ5dGVPZmZzZXQgKyBiLmJ5dGVMZW5ndGggJiYgLy8gYSBzdGFydHMgYmVmb3JlIGIgZW5kXG4gICAgICAgIGIuYnl0ZU9mZnNldCA8IGEuYnl0ZU9mZnNldCArIGEuYnl0ZUxlbmd0aCAvLyBiIHN0YXJ0cyBiZWZvcmUgYSBlbmRcbiAgICApO1xufVxuLyoqXG4gKiBJZiBpbnB1dCBhbmQgb3V0cHV0IG92ZXJsYXAgYW5kIGlucHV0IHN0YXJ0cyBiZWZvcmUgb3V0cHV0LCB3ZSB3aWxsIG92ZXJ3cml0ZSBlbmQgb2YgaW5wdXQgYmVmb3JlXG4gKiB3ZSBzdGFydCBwcm9jZXNzaW5nIGl0LCBzbyB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG1vc3QgY2lwaGVycyAoZXhjZXB0IGNoYWNoYS9zYWxzZSwgd2hpY2ggZGVzaWduZWQgd2l0aCB0aGlzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGxleE92ZXJsYXBCeXRlcyhpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gVGhpcyBpcyB2ZXJ5IGN1cnNlZC4gSXQgd29ya3Mgc29tZWhvdywgYnV0IEknbSBjb21wbGV0ZWx5IHVuc3VyZSxcbiAgICAvLyByZWFzb25pbmcgYWJvdXQgb3ZlcmxhcHBpbmcgYWxpZ25lZCB3aW5kb3dzIGlzIHZlcnkgaGFyZC5cbiAgICBpZiAob3ZlcmxhcEJ5dGVzKGlucHV0LCBvdXRwdXQpICYmIGlucHV0LmJ5dGVPZmZzZXQgPCBvdXRwdXQuYnl0ZU9mZnNldClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wbGV4IG92ZXJsYXAgb2YgaW5wdXQgYW5kIG91dHB1dCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIENvbXBhcmVzIDIgdWludDhhcnJheS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWUuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIFdyYXBzIGEgY2lwaGVyOiB2YWxpZGF0ZXMgYXJncywgZW5zdXJlcyBlbmNyeXB0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5leHBvcnQgY29uc3Qgd3JhcENpcGhlciA9IChwYXJhbXMsIGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgZnVuY3Rpb24gd3JhcHBlZENpcGhlcihrZXksIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUga2V5XG4gICAgICAgIGFieXRlcyhrZXksIHVuZGVmaW5lZCwgJ2tleScpO1xuICAgICAgICAvLyBCaWctRW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgbm9uY2UgaWYgbm9uY2VMZW5ndGggaXMgcHJlc2VudFxuICAgICAgICBpZiAocGFyYW1zLm5vbmNlTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gYXJnc1swXTtcbiAgICAgICAgICAgIGFieXRlcyhub25jZSwgcGFyYW1zLnZhclNpemVOb25jZSA/IHVuZGVmaW5lZCA6IHBhcmFtcy5ub25jZUxlbmd0aCwgJ25vbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgQUFEIGlmIHRhZ0xlbmd0aCBwcmVzZW50XG4gICAgICAgIGNvbnN0IHRhZ2wgPSBwYXJhbXMudGFnTGVuZ3RoO1xuICAgICAgICBpZiAodGFnbCAmJiBhcmdzWzFdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhYnl0ZXMoYXJnc1sxXSwgdW5kZWZpbmVkLCAnQUFEJyk7XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNvbnN0cnVjdG9yKGtleSwgLi4uYXJncyk7XG4gICAgICAgIGNvbnN0IGNoZWNrT3V0cHV0ID0gKGZuTGVuZ3RoLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmbkxlbmd0aCAhPT0gMilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaXBoZXIgb3V0cHV0IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBhYnl0ZXMob3V0cHV0LCB1bmRlZmluZWQsICdvdXRwdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlIHdyYXBwZWQgY2lwaGVyIHdpdGggdmFsaWRhdGlvbiBhbmQgc2luZ2xlLXVzZSBlbmNyeXB0aW9uXG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd3JDaXBoZXIgPSB7XG4gICAgICAgICAgICBlbmNyeXB0KGRhdGEsIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGVuY3J5cHQoKSB0d2ljZSB3aXRoIHNhbWUga2V5ICsgbm9uY2UnKTtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgICAgICAgICBjaGVja091dHB1dChjaXBoZXIuZW5jcnlwdC5sZW5ndGgsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlci5lbmNyeXB0KGRhdGEsIG91dHB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjcnlwdChkYXRhLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ2wgJiYgZGF0YS5sZW5ndGggPCB0YWdsKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY2lwaGVydGV4dFwiIGV4cGVjdGVkIGxlbmd0aCBiaWdnZXIgdGhhbiB0YWdMZW5ndGg9JyArIHRhZ2wpO1xuICAgICAgICAgICAgICAgIGNoZWNrT3V0cHV0KGNpcGhlci5kZWNyeXB0Lmxlbmd0aCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVyLmRlY3J5cHQoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3ckNpcGhlcjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVkQ2lwaGVyLCBwYXJhbXMpO1xuICAgIHJldHVybiB3cmFwcGVkQ2lwaGVyO1xufTtcbi8qKlxuICogQnkgZGVmYXVsdCwgcmV0dXJucyB1OGEgb2YgbGVuZ3RoLlxuICogV2hlbiBvdXQgaXMgYXZhaWxhYmxlLCBpdCBjaGVja3MgaXQgZm9yIHZhbGlkaXR5IGFuZCB1c2VzIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3V0cHV0KGV4cGVjdGVkTGVuZ3RoLCBvdXQsIG9ubHlBbGlnbmVkID0gdHJ1ZSkge1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkTGVuZ3RoKTtcbiAgICBpZiAob3V0Lmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJvdXRwdXRcIiBleHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnLCBnb3Q6ICcgKyBvdXQubGVuZ3RoKTtcbiAgICBpZiAob25seUFsaWduZWQgJiYgIWlzQWxpZ25lZDMyKG91dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvdXRwdXQsIG11c3QgYmUgYWxpZ25lZCcpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdTY0TGVuZ3RocyhkYXRhTGVuZ3RoLCBhYWRMZW5ndGgsIGlzTEUpIHtcbiAgICBhYm9vbChpc0xFKTtcbiAgICBjb25zdCBudW0gPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcobnVtKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NCgwLCBCaWdJbnQoYWFkTGVuZ3RoKSwgaXNMRSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoOCwgQmlnSW50KGRhdGFMZW5ndGgpLCBpc0xFKTtcbiAgICByZXR1cm4gbnVtO1xufVxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5leHBvcnQgZnVuY3Rpb24gaXNBbGlnbmVkMzIoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG4vLyBjb3B5IGJ5dGVzIHRvIG5ldyB1OGEgKGFsaWduZWQpLiBCZWNhdXNlIEJ1ZmZlci5zbGljZSBpcyBicm9rZW4uXG5leHBvcnQgZnVuY3Rpb24gY29weUJ5dGVzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShieXRlcyk7XG59XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBjb25zdCBjciA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogbnVsbDtcbiAgICBpZiAodHlwZW9mIGNyPy5nZXRSYW5kb21WYWx1ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4gY3IuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG59XG4vKipcbiAqIFVzZXMgQ1NQUkcgZm9yIG5vbmNlLCBub25jZSBpbmplY3RlZCBpbiBjaXBoZXJ0ZXh0LlxuICogRm9yIGBlbmNyeXB0YCwgYSBgbm9uY2VCeXRlc2AtbGVuZ3RoIGJ1ZmZlciBpcyBmZXRjaGVkIGZyb20gQ1NQUk5HIGFuZFxuICogcHJlcGVuZGVkIHRvIGVuY3J5cHRlZCBjaXBoZXJ0ZXh0LiBGb3IgYGRlY3J5cHRgLCBmaXJzdCBgbm9uY2VCeXRlc2Agb2YgY2lwaGVydGV4dFxuICogYXJlIHRyZWF0ZWQgYXMgbm9uY2UuXG4gKlxuICogTk9URTogVW5kZXIgdGhlIHNhbWUga2V5LCB1c2luZyByYW5kb20gbm9uY2VzIChlLmcuIGBtYW5hZ2VkTm9uY2VgKSB3aXRoIEFFUy1HQ00gYW5kIENoYUNoYVxuICogc2hvdWxkIGJlIGxpbWl0ZWQgdG8gYDIqKjIzYCAoOE0pIG1lc3NhZ2VzIHRvIGdldCBhIGNvbGxpc2lvbiBjaGFuY2Ugb2YgYDIqKi01MGAuIFN0cmV0Y2hpbmcgdG8gICogYDIqKjMyYCAoNEIpIG1lc3NhZ2VzLCBjaGFuY2Ugd291bGQgYmVjb21lIGAyKiotMzNgIC0gc3RpbGwgbmVnbGlnaWJsZSwgYnV0IGNyZWVwaW5nIHVwLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGdjbSA9IG1hbmFnZWROb25jZShhZXMuZ2NtKTtcbiAqIGNvbnN0IGNpcGhyID0gZ2NtKGtleSkuZW5jcnlwdChkYXRhKTtcbiAqIGNvbnN0IHBsYWluID0gZ2NtKGtleSkuZGVjcnlwdChjaXBoKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hbmFnZWROb25jZShmbiwgcmFuZG9tQnl0ZXNfID0gcmFuZG9tQnl0ZXMpIHtcbiAgICBjb25zdCB7IG5vbmNlTGVuZ3RoIH0gPSBmbjtcbiAgICBhbnVtYmVyKG5vbmNlTGVuZ3RoKTtcbiAgICBjb25zdCBhZGROb25jZSA9IChub25jZSwgY2lwaGVydGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBvdXQgPSBjb25jYXRCeXRlcyhub25jZSwgY2lwaGVydGV4dCk7XG4gICAgICAgIGNpcGhlcnRleHQuZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBzdXBwb3J0IERTVCBoZXJlLCBpdCB3b3VsZCBiZSBtaXN0YWtlOlxuICAgIC8vIC0gd2UgZG9uJ3Qga25vdyBob3cgbXVjaCBkc3QgbGVuZ3RoIGNpcGhlciByZXF1aXJlc1xuICAgIC8vIC0gbm9uY2UgbWF5IHVuYWxpZ24gZHN0IGFuZCBicmVhayBldmVyeXRoaW5nXG4gICAgLy8gLSB3ZSBjcmVhdGUgbmV3IHU4YSBhbnl3YXkgKGNvbmNhdEJ5dGVzKVxuICAgIC8vIC0gcHJldmlvdXNseSB3ZSBwYXNzZWQgYWxsIGFyZ3MgdG8gY2lwaGVyLCBidXQgdGhhdCB3YXMgbWlzdGFrZSFcbiAgICByZXR1cm4gKChrZXksIC4uLmFyZ3MpID0+ICh7XG4gICAgICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgICAgICBhYnl0ZXMocGxhaW50ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gcmFuZG9tQnl0ZXNfKG5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGZuKGtleSwgbm9uY2UsIC4uLmFyZ3MpLmVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChlbmNyeXB0ZWQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0ZWQudGhlbigoY3QpID0+IGFkZE5vbmNlKG5vbmNlLCBjdCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZE5vbmNlKG5vbmNlLCBlbmNyeXB0ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgICAgIGFieXRlcyhjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCBub25jZUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KG5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBmbihrZXksIG5vbmNlLCAuLi5hcmdzKS5kZWNyeXB0KGRlY3J5cHRlZCk7XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@noble+ciphers@2.0.1/node_modules/@noble/ciphers/utils.js\n");

/***/ })

};
;